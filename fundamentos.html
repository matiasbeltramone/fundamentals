<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fundamentos de Programaci√≥n - Portal de Programaci√≥n</title>
    <meta name="description" content="Aprende qu√© es programar realmente, conceptos b√°sicos y paradigmas de programaci√≥n">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <!-- Added cache busting parameter to force CSS reload -->
    <link rel="stylesheet" href="styles.css?v=2">
</head>
<body>
<!-- Navigation -->
<nav class="navbar">
    <div class="nav-container">
        <div class="nav-content">
            <div class="nav-brand">
                <div class="nav-logo">üìö</div>
                <h1><a href="index.html">Portal de Programaci√≥n</a></h1>
            </div>
            <div class="nav-links">
                <a href="index.html">‚Üê Volver al inicio</a>
            </div>
        </div>
    </div>
</nav>

<!-- Article Header -->
<header class="article-header">
    <div class="container">
        <div class="breadcrumb">
            <a href="index.html">Inicio</a>
            <span class="breadcrumb-separator">‚Üí</span>
            <span>Fundamentos de Programaci√≥n</span>
        </div>

        <div class="article-meta">
            <div class="article-category fundamentals">üíª Conceptos b√°sicos</div>
            <h1 class="article-title">Fundamentos de Programaci√≥n</h1>
            <p class="article-subtitle">Descubre qu√© es programar realmente y los conceptos esenciales del desarrollo de software</p>

            <div class="article-info">
                <span class="info-item">‚è±Ô∏è 12 min de lectura</span>
                <span class="info-item">üè∑Ô∏è Nivel b√°sico</span>
                <span class="info-item">üìÖ Actualizado recientemente</span>
            </div>
        </div>
    </div>
</header>

<!-- Article Content -->
<main class="article-content">
    <div class="container">
        <article class="content">
            <section class="content-section">
                <h2>üíª ¬øQu√© es programar? Y, ¬øqu√© es un programa?</h2>
                <p>¬°Comencemos! Si est√°s aqu√≠, es probable que ya hayas escuchado las palabras "programar" o "programa" mil veces, pero quiz√°s no tengas del todo claro a qu√© nos referimos. ¬°No te preocupes! En este post, vamos a desglosar estos conceptos de la forma m√°s simple posible.</p>
            </section>

            <section class="content-section">
                <h3>1. Descomponiendo el concepto: Programaci√≥n Web üåê</h3>
                <p>Cuando decimos <strong>programaci√≥n web</strong>, estamos uniendo dos ideas principales:</p>
                <ol>
                    <li><strong>Programaci√≥n:</strong> El acto de crear un <strong>programa</strong>.</li>
                    <li><strong>Web:</strong> El universo de internet, sitios y servicios a los que accedemos.</li>
                </ol>
                <p>Para entender la <em>programaci√≥n web</em>, primero necesitamos entender qu√© es programar y qu√© es un programa. ¬°Vamos a empezar por ah√≠!</p>
            </section>

            <section class="content-section">
                <h3>2. El misterio del Programa: ¬øQu√© es? üßê</h3>
                <p>Probablemente, la definici√≥n m√°s com√∫n que encuentres sea: "<em>Un programa es una secuencia de instrucciones para una computadora</em>".</p>

                <p>Aunque no es del todo incorrecta, esta definici√≥n es un poco limitada. Piensa en esto:</p>

                <div class="highlight-box warning">
                    <ul>
                        <li>‚ùå <strong>Es como si dij√©ramos que la astronom√≠a es la "ciencia de mirar por un telescopio".</strong> El <strong>telescopio</strong> es solo una <strong>herramienta</strong>, <strong>no</strong> el <strong>objeto de estudio</strong>.</li>
                        <li>‚ùå <strong>No todos los programas son una lista de pasos.</strong> Por ejemplo, hay lenguajes (como Prolog) donde le das a la computadora hechos y reglas, y ella saca sus propias conclusiones, sin una secuencia de instrucciones fija que le diga que acciones realizar.</li>
                    </ul>
                </div>

                <h4>üñ•Ô∏è La m√°quina de Von Neumann: El porqu√© de la definici√≥n cl√°sica üß†</h4>
                <p>La definici√≥n de programa como una "secuencia de instrucciones" tiene sus ra√≠ces en la forma en que se construyen y operan la mayor√≠a de las computadoras que usamos hoy en d√≠a. Esto se conoce como la <strong>arquitectura de Von Neumann</strong>, un modelo que fue fundamental para el desarrollo de la computaci√≥n.</p>

                <p>En esta arquitectura, la computadora funciona con dos componentes principales:</p>
                <ul>
                    <li><strong>CPU (Unidad Central de Procesamiento):</strong> El "cerebro" que realiza los c√°lculos.</li>
                    <li><strong>Memoria (RAM):</strong> Donde se almacenan tanto el programa como los datos que se van a usar.</li>
                </ul>

                <p>El programa, literalmente, es una serie de instrucciones almacenadas una tras otra en la memoria. La CPU las ejecuta en un ciclo continuo que se conoce como <strong>Fetch-Decode-Execute</strong> (Buscar-Decodificar-Ejecutar):</p>

                <div class="code-block">
                    <ol>
                        <li><strong>Fetch (Buscar):</strong> La CPU va a la memoria y <strong>busca</strong> la siguiente instrucci√≥n.</li>
                        <li><strong>Decode (Decodificar):</strong> La CPU <strong>decodifica</strong> (traduce) esa instrucci√≥n para entender qu√© debe hacer.</li>
                        <li><strong>Execute (Ejecutar):</strong> La CPU <strong>ejecuta</strong> la acci√≥n indicada por la instrucci√≥n (por ejemplo, sumar dos n√∫meros, mover un dato, etc.).</li>
                    </ol>
                </div>

                <p>Este ciclo es una <strong>secuencia de pasos</strong>, uno detr√°s del otro. Por eso, hist√≥ricamente, la definici√≥n de un programa se at√≥ a este modelo. La limitaci√≥n es que confunde el concepto de programa con una herramienta espec√≠fica (la arquitectura Von Neumann), en lugar de centrarse en la esencia del programa en s√≠.</p>
            </section>

            <section class="content-section">
                <h3>üß© Un ejemplo para contrastar: La l√≥gica de Prolog üß†</h3>
                <p>Para entender que no todos los programas son una secuencia de pasos, vamos a ver un ejemplo con el lenguaje <strong>Prolog</strong>, que sigue el paradigma de <strong>programaci√≥n l√≥gica</strong> ya que lo mencionamos anteriormente, lo vamos a detallar un poco.</p>

                <p>Imagina que queremos que la computadora sepa si un elemento est√° en una lista. En un lenguaje tradicional (basado en Von Neumann), le dir√≠amos: "Ve al primer elemento de la lista. Si es el que buscas, detente. Si no, ve al segundo. Repite esto hasta que lo encuentres o la lista se termine."</p>

                <p>En Prolog, la forma de pensar es totalmente diferente. Le decimos a la computadora la <strong>l√≥gica</strong> del problema a trav√©s de <strong>hechos</strong> y <strong>reglas</strong>, y luego le preguntamos.</p>

                <div class="code-block">
                    <h5>Hechos:</h5>
                    <pre><code>contiene(X, [X | _]).</code></pre>
                    <p>Este es un <strong>hecho</strong> que dice: El elemento <strong>X</strong> est√° en una lista si <strong>X</strong> es el <strong>primer elemento</strong> de la lista (el <code>| _</code> significa "el resto de la lista no me importa").</p>

                    <h5>Reglas:</h5>
                    <pre><code>contiene(Y, [_ | XS]) :- contiene(Y, XS).</code></pre>
                    <p>Esta es una <strong>regla</strong> que dice: El elemento <strong>Y</strong> est√° en una lista si <strong>Y</strong> est√° en el <strong>resto de la lista</strong> (el <code>_</code> significa "el primer elemento no me importa").</p>
                </div>

                <h4>¬øC√≥mo funciona? ü§î</h4>
                <p>Cuando le preguntas a Prolog si un n√∫mero est√° en una lista, por ejemplo, <code>contiene(2, [1, 2, 3]).</code>, el programa no sigue una secuencia de pasos. En su lugar, el <strong>motor de inferencia</strong> de Prolog razona as√≠:</p>

                <div class="highlight-box info">
                    <ul>
                        <li><strong>Paso 1:</strong> "Quiero saber si el 2 est√° en <code>[1, 2, 3]</code>."</li>
                        <li><strong>Paso 2:</strong> "La regla <code>contiene(X, [X | _])</code> no aplica porque el 2 no es el primer elemento (lo es el 1 en este caso)."</li>
                        <li><strong>Paso 3:</strong> "Entonces, voy a usar la otra regla: <code>contiene(Y, [_ | XS]) :- contiene(Y, XS).</code>"</li>
                        <li><strong>Paso 4:</strong> "Esta regla me dice que, para saber si el 2 est√° en <code>[1, 2, 3]</code>, solo necesito saber si el 2 est√° en el <strong>resto de la lista</strong>, es decir, en <code>[2, 3]</code>."</li>
                        <li><strong>Paso 5:</strong> "Ahora, la pregunta es: ¬øest√° el 2 en <code>[2, 3]</code>?"</li>
                        <li><strong>Paso 6:</strong> "¬°S√≠! La primera regla <code>contiene(X, [X | _])</code> aplica ahora, porque el 2 es el primer elemento de la lista <code>[2, 3]</code>."</li>
                        <li><strong>Conclusi√≥n:</strong> "¬°<code>True</code> (verdadero)!"</li>
                    </ul>
                </div>

                <p>Como ves, en este ejemplo, no le dimos una serie de pasos fijos a la computadora. Simplemente le dimos la l√≥gica, y ella us√≥ esa l√≥gica para encontrar la respuesta.</p>
                <p>Adem√°s, podr√°s observar que esto simplemente es otro estilo de programar, te preguntar√°s que son los paradigmas de programaci√≥n que de alguna manera venimos charlando en los ejemplos.</p>
            </section>

            <section class="content-section">
                <h3>¬øQu√© son los paradigmas de programaci√≥n? üí°</h3>
                <p>Un paradigma de programaci√≥n es una filosof√≠a o un estilo para construir programas. Piensa en ello como una forma de pensar sobre c√≥mo resolver un problema. Hay muchos paradigmas, cada uno con sus propias reglas y conceptos.</p>

                <p>As√≠ como en la pintura existen diferentes estilos (realismo, impresionismo, etc.), en programaci√≥n existen varios paradigmas. Cada uno tiene sus propias ideas sobre qu√© es un programa y c√≥mo se debe construir. Los dos grandes grupos que podemos diferenciar son:</p>

                <div class="paradigms-grid">
                    <div class="paradigm-card">
                        <h4>Paradigmas imperativos</h4>
                        <p>Aqu√≠ le dices a la computadora <strong>"c√≥mo hacer algo"</strong>, paso a paso.</p>
                        <ul>
                            <li><strong>Programaci√≥n procedural:</strong> Escribes un programa como una secuencia de procedimientos o subrutinas. Es el enfoque m√°s tradicional.</li>
                            <li><strong>Programaci√≥n orientada a objetos (POO):</strong> Organizas el c√≥digo en "objetos" que contienen tanto datos como las acciones que pueden realizarse con esos datos. Es muy popular hoy en d√≠a.</li>
                        </ul>
                    </div>

                    <div class="paradigm-card">
                        <h4>Paradigmas declarativos</h4>
                        <p>Aqu√≠ le dices a la computadora <strong>"qu√© hacer"</strong>, sin especificar el c√≥mo. La computadora se encarga de resolverlo.</p>
                        <ul>
                            <li><strong>Programaci√≥n l√≥gica:</strong> Como en el ejemplo de Prolog, defines hechos y reglas para que el programa deduzca una soluci√≥n.</li>
                            <li><strong>Programaci√≥n funcional:</strong> Se basa en funciones matem√°ticas, donde cada funci√≥n toma una entrada y produce una salida, sin modificar nada fuera de ella. Es muy popular para resolver problemas complejos y concurrentes.</li>
                        </ul>
                    </div>
                </div>

                <h4>Entonces, ¬øLa definici√≥n m√°s difundida est√° mal? ü§î</h4>

                <p>En definitiva, solo no es del todo completa... La definici√≥n cl√°sica de programa se centra en el paradigma imperativo y lo trata como si fuera la √∫nica forma de programar. Sin embargo, como vimos con el ejemplo de Prolog, hay otras formas de pensar un programa que no se basan en una secuencia de instrucciones. El t√©rmino paradigma engloba todas estas diferentes "filosof√≠as", tanto las que usan secuencias de pasos como las que no.</p>
            </section>

            <section class="content-section">
                <h3>Bien, ¬øcu√°l es una mejor definici√≥n? ü§î</h3>

                <div class="highlight-box info">
                    <p>Un programa es la representaci√≥n de conocimiento ejecutable sobre un dominio de inter√©s. üí°</p>
                </div>

                <p>Nosotros al menos, vamos a pensar en un programa como <strong>la representaci√≥n de conocimiento sobre un dominio de inter√©s, que es ejecutable por una computadora.</strong></p>

                <p>Claramente, lo que se busca es tener un pensamiento cr√≠tico y definiciones verdaderas y √∫nicas no suelen suceder demasiado en la industria, nadie suele ser due√±o de la verdad, pero los invito a pensar si les cierra m√°s la idea con base en todo lo planteado anteriormente.
                    Por la formaci√≥n que recib√≠ de otros colegas mi pensamiento fue variando con el paso de los a√±os y en el intento de mejorar el vocabulario y del entender de la profesi√≥n me cierra m√°s este camino.
                </p>

                <p>Analicemos esto por partes:</p>
                <ul>
                    <li><strong>Representaci√≥n de conocimiento:</strong> El programa es un <strong>modelo</strong> o al menos como lo busco entender de mi parte. Es nuestra forma de "traducir" la realidad (un negocio, un problema, un juego) a un lenguaje que la computadora pueda entender.</li>
                    <li><strong>Dominio de inter√©s:</strong> Es el tema o √°rea sobre la que estamos trabajando.
                        <ul>
                            <li><strong>Ejemplo de Dominio de negocio:</strong> Si creas un sistema para un supermercado, tu dominio es c√≥mo funciona ese supermercado: los productos, las ventas, los clientes, etc.</li>
                            <li><strong>Ejemplo de Dominio de problema:</strong> Si haces una app para resolver Sudokus, el dominio es la l√≥gica de ese juego.</li>
                        </ul>
                    </li>
                    <li><strong>Ejecutable:</strong> Significa que una computadora puede "leer" y "correr" este modelo para obtener un resultado.</li>
                </ul>

                <div class="highlight-box success">
                    <p>Esta definici√≥n es mucho m√°s amplia y √∫til, porque nos muestra que un programa no es solo c√≥digo t√©cnico, ¬°tambi√©n es una expresi√≥n de ideas y de nuestra compleja realidad!</p>
                </div>
            </section>

            <section class="content-section">
                <h3>üßê Lenguaje vs. Paradigma: No son lo mismo üë©‚Äçüè´</h3>

                <p>Ya hablamos de los paradigmas como las "filosof√≠as" o estilos de programaci√≥n (imperativo, declarativo, etc.). Ahora, un lenguaje de programaci√≥n (como JavaScript, Python o C++) es la herramienta que usamos para escribir el programa.</p>

                <p>La confusi√≥n surge porque muchos lenguajes est√°n fuertemente asociados con un paradigma en particular. Por ejemplo:</p>

                <ul>
                    <li><strong>Python y Java</strong> se asocian mucho con la <strong>programaci√≥n orientada a objetos</strong>.</li>
                    <li><strong>Haskell</strong> est√° muy ligado a la <strong>programaci√≥n funcional.</strong></li>
                    <li><strong>Prolog</strong> es el ejemplo cl√°sico de la <strong>programaci√≥n l√≥gica.</strong></li>
                </ul>

                <div class="highlight-box tip">
                    <p><strong>üí° Tip:</strong> Es importante conocer que muchos lenguajes modernos son multiparadigma.</p>
                </div>

                <p>Esto significa que un solo lenguaje te permite escribir c√≥digo usando diferentes estilos. El mejor ejemplo es JavaScript, que vamos a ver en la parte de web sin dudas.</p>

                <ul>
                    <li>Puedes escribir c√≥digo imperativo (con instrucciones paso a paso).</li>
                    <li>Tambi√©n puedes usar programaci√≥n orientada a objetos (creando "objetos" con datos y funciones).</li>
                    <li>Y puedes aplicar conceptos de programaci√≥n funcional (usando funciones como ciudadanos de primera clase, funciones puras, etc.).</li>
                </ul>

                <h4>¬øPor qu√© es esto importante?</h4>

                <p>Entender esto da la libertad de elegir la mejor herramienta (el lenguaje) para el problema, y al mismo tiempo les permite explorar diferentes formas de pensar sin tener que cambiar de lenguaje constantemente.</p>
            </section>

            <section class="content-section">
                <h3>3. El proceso de Programar: M√°s que escribir c√≥digo ‚úçÔ∏è</h3>
                <p>Si un programa es el <strong>producto</strong>, entonces <strong>programar</strong> es el <strong>proceso</strong> de crearlo. Pero este proceso no es lineal, no es solo sentarse a escribir c√≥digo de principio a fin.</p>

                <div class="highlight-box info">
                    <h4>Programar es un proceso de aprendizaje continuo. üß†</h4>
                </div>

                <p>Como programadores, no llegamos sabiendo todo sobre el <strong>dominio de inter√©s</strong>. Nuestro trabajo es:</p>
                <ol>
                    <li><strong>Escuchar y observar:</strong> Hablar con las personas que entienden el negocio (el due√±o del supermercado, los empleados, los clientes).</li>
                    <li><strong>Aprender:</strong> Entender las reglas, los procesos y las necesidades del dominio.</li>
                    <li><strong>Representar:</strong> Convertir todo ese conocimiento en un <strong>programa</strong> que la computadora pueda <strong>ejecutar</strong>.</li>
                </ol>

                <p>Este proceso nunca termina. Los negocios y los problemas evolucionan, las leyes cambian, la tecnolog√≠a avanza. Por eso, el programa tambi√©n necesita evolucionar. Casi siempre, trabajar√°s en un programa que ya existe y que est√° siendo usado, y tu tarea ser√° adaptarlo y mejorarlo.</p>

                <div class="highlight-box tip">
                    <p><strong>üí° Tip:</strong> Programar no solo requiere habilidades t√©cnicas, tambi√©n necesitas ser un buen observador y un gran comunicador. Eres un solucionador de problemas, y para resolverlos, primero debes entenderlos.</p>
                </div>
            </section>

            <section class="content-section">
                <h3>Resumen para llevar a casa üöÄ</h3>
                <div class="summary-box">
                    <ul>
                        <li><strong>Un programa</strong> no es solo una lista de instrucciones, es una <strong>representaci√≥n ejecutable del conocimiento</strong> sobre un dominio de inter√©s.</li>
                        <li><strong>Programar</strong> es un <strong>proceso de aprendizaje constante</strong>, donde observamos el mundo, entendemos un problema y lo traducimos a un lenguaje que la computadora pueda usar.</li>
                        <li><strong>La programaci√≥n profesional</strong> es un oficio que combina habilidades t√©cnicas con la capacidad de entender y <strong>colaborar en un mundo din√°mico y complejo.</strong></li>
                    </ul>
                </div>
            </section>
        </article>
    </div>
</main>

<!-- Navigation Footer -->
<section class="article-navigation">
    <div class="container">
        <div class="nav-links">
            <a href="index.html" class="nav-link prev">
                <span class="nav-direction">‚Üê Anterior</span>
                <span class="nav-title">Volver al inicio</span>
            </a>
            <a href="git.html" class="nav-link next">
                <span class="nav-direction">Siguiente ‚Üí</span>
                <span class="nav-title">Introducci√≥n a Git</span>
            </a>
        </div>
    </div>
</section>

<!-- Footer -->
<footer class="footer">
    <div class="container">
        <div class="footer-content">
            <div class="footer-brand">
                <div class="footer-logo">üìö</div>
                <span>Portal de Programaci√≥n</span>
            </div>
            <p class="footer-text">Hecho con ‚ù§Ô∏è para estudiantes y desarrolladores</p>
            <p class="footer-small">Desplegado con GitHub Pages ‚Ä¢ Actualizado regularmente</p>
        </div>
    </div>
</footer>
</body>
</html>
